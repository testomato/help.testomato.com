"use strict";(self.webpackChunkhelp=self.webpackChunkhelp||[]).push([[4758],{29910:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"checks/CSRF-protection","title":"CSRF protection","description":"Testomato & CSRF protection","source":"@site/docs/checks/05-CSRF-protection.md","sourceDirName":"checks","slug":"/checks/CSRF-protection","permalink":"/checks/CSRF-protection","draft":false,"unlisted":false,"editUrl":"https://github.com/testomato/help.testomato.com/edit/master/docs/checks/05-CSRF-protection.md","tags":[],"version":"current","lastUpdatedAt":1771251101000,"sidebarPosition":5,"frontMatter":{"title":"CSRF protection"},"sidebar":"docs","previous":{"title":"Common Server Errors","permalink":"/checks/common-server-errors"},"next":{"title":"Notifications and alerts","permalink":"/checks/notifications"}}');var i=s(74848),o=s(28453);const r={title:"CSRF protection"},a=void 0,c={},l=[{value:"Testomato &amp; CSRF protection",id:"testomato--csrf-protection",level:2},{value:"What is CSRF protection",id:"what-is-csrf-protection",level:2},{value:"Preventing CSRF Requests",id:"preventing-csrf-requests",level:3},{value:"Per-Form Tokens",id:"per-form-tokens",level:3},{value:"Resources",id:"resources",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"testomato--csrf-protection",children:"Testomato & CSRF protection"}),"\n",(0,i.jsxs)(t.p,{children:["Can Testomato handle forms with CSRF protection? The simply answer is NO.\nIf your application is protected from cross-site request forgery attacks, it's also\npreventing Testomato from sending requests with ",(0,i.jsx)(t.a,{href:"https://github.com/testomato/minicrawler",children:"minicrawler"}),", but we can try to\nbridge the simplest type of protection by doubling the request."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"During the first request"}),", Testomato ignores HTTP response code -\nusually there\u2019s some sort of unauthorized request response,\nbut we update all hidden form params values and save the session."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"The second request"})," is submitted within the same session in the hopes that one of the hidden params has a valid CSRF token"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"what-is-csrf-protection",children:"What is CSRF protection"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",children:"Cross-site request forgeries"})," are a type of malicious\nexploit where unauthorized commands are performed on behalf of an authenticated user."]}),"\n",(0,i.jsx)(t.p,{children:"In case you're not familiar with cross-site request forgeries, let's discuss an example of how this\nvulnerability can be exploited."}),"\n",(0,i.jsxs)(t.p,{children:["Imagine your application has a ",(0,i.jsx)(t.code,{children:"/user/email"})," route that accepts a\n",(0,i.jsx)(t.code,{children:"POST"})," request to change the authenticated user's email address. This route most likely expects\nan email input field to contain the email address the user would like to begin using."]}),"\n",(0,i.jsxs)(t.p,{children:["Without CSRF protection, a malicious website could create an HTML form that points to your\napplication's ",(0,i.jsx)(t.code,{children:"/user/email"})," route and submits the malicious user's own email address"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-html",children:'<form action="https://your-application.com/user/email" method="POST">\n  <input type="email" value="malicious-email@example.com">\n</form>\n\n<script>\n  document.forms[0].submit();\n<\/script>\n'})}),"\n",(0,i.jsx)(t.h3,{id:"preventing-csrf-requests",children:"Preventing CSRF Requests"}),"\n",(0,i.jsx)(t.p,{children:'You can generate a CSRF "token" for each active user session managed by the application.\nThis token is used to verify that the authenticated user is the person actually making\nthe requests to the application. Since this token is stored in the user\'s session\nand changes each time the session is regenerated, a malicious application is unable to access it.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:'<?php\nsession_start();\nif (empty($_SESSION[\'token\'])) {\n    $_SESSION[\'token\'] = bin2hex(random_bytes(32));\n}\n$token = $_SESSION[\'token\'];\n?>\n<form action="https://your-application.com/user/email" method="POST">\n  <input type="email" value="malicious-email@example.com">\n  <input type="hidden" name="token" value="<?php echo $token ?>" />\n</form>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Anytime you define an HTML form in your application,\nyou should include a hidden CSRF ",(0,i.jsx)(t.code,{children:"_token"})," field in the\nform so that the CSRF protection can validate the request."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"if (!empty($_POST['token'])) {\n    if (hash_equals($_SESSION['token'], $_POST['token'])) {\n         // Proceed to process the form data\n    } else {\n         // Log this as a warning and keep an eye on these attempts\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"per-form-tokens",children:"Per-Form Tokens"}),"\n",(0,i.jsx)(t.p,{children:"You can go even further and generate Per-Form Tokens for every single\nform on your application:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"<?php $second_token = hash_hmac('sha256', '/my_form.php', $_SESSION['second_token']); ?>\n<input type=\"hidden\" name=\"token\" value=\"<?php echo $second_token ?>\" />\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-php",children:"<?php\n$calc = hash_hmac('sha256', '/my_form.php', $_SESSION['second_token']);\nif (hash_equals($calc, $_POST['token'])) {\n    // Continue...\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"You can also change the name of the token variable or invalidate a token\nperiodically in time. If you have a security requirement that each CSRF\ntoken is allowed to be usable exactly once, the simplest strategy\nis to regenerate it after each successful validation.\nHowever, doing so will invalidate every previous token, which can negatively\nimpact the experience of users who browse multiple tabs simultaneously."}),"\n",(0,i.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",children:"Cross-site request forgeries"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://laravel.com/docs/8.x/csrf#csrf-explanation",children:"CSRF Protection with Laravel"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://symfony.com/doc/current/security/csrf.html",children:"CSRF Protection with Symfony"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://github.com/expressjs/csurf",children:"CSRF Protection with Express.js"})}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);